---
title: "IDRGP 2023"
author: "FPR e DG"
date: "2024-04-05"
output:
  html_document: default
  pdf_document: default
---

# IDRGP 2023

## **Script para o monitoramento do IDRGP no exercício de 2023**

### Intodução

**Objetivo**: levantar, tratar e analisar dados dos valores executados, nas regiões da cidade de são paulo a partir de uma cesta de desepesas selecionadas, que incluem o Programa de Metas 2021-2024 Versão Alteração Programática, uma lista de obras monitoradas e intervenções do Orçamento Cidadão

### Pacotes utilizados:

```{r Pacotes, echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}

library(tidyverse)
library(readxl)
library(sf)
library(tinytex)
library(janitor)


base::options(scipen = 99, digits = 2)

```

### Valores de referência do IDRGP

Inicialmente, inserimos os valores de referência do IDRGP:

```{r Valores de referência, echo=FALSE, message=FALSE, warning=FALSE}
(ref_idrgp <- dplyr::tibble(sp_nome = c("Subprefeitura Capela do Socorro",
                                        "Subprefeitura M'Boi Mirim",
                                        "Subprefeitura Campo Limpo",
                                        "Subprefeitura São Mateus",
                                        "Subprefeitura Itaquera",
                                        "Subprefeitura Cidade Ademar",
                                        "Subprefeitura Freguesia/Brasilândia",
                                        "Subprefeitura São Miguel Paulista",
                                        "Subprefeitura Itaim Paulista",
                                        "Subprefeitura Pirituba/Jaraguá",
                                        "Subprefeitura Parelheiros",
                                        "Subprefeitura Jaçanã/Tremembé",
                                        "Subprefeitura Sapopemba",
                                        "Subprefeitura de Guaianases",
                                        "Subprefeitura Penha",
                                        "Subprefeitura Ipiranga",
                                        "Subprefeitura Cidade Tiradentes",
                                        "Subprefeitura Casa Verde/Cachoeirinha",
                                        "Subprefeitura Perus/Anhanguera",
                                        "Subprefeitura Butantã",
                                        "Subprefeitura Ermelino Matarazzo",
                                        "Subprefeitura de Vila Prudente",
                                        "Subprefeitura Sé",
                                        "Subprefeitura Vila Maria/Vila Guilherme",
                                        "Subprefeitura Aricanduva/Formosa/Carrão",
                                        "Subprefeitura Jabaquara",
                                        "Subprefeitura Mooca",
                                        "Subprefeitura Santana/Tucuruvi",
                                        "Subprefeitura Lapa",
                                        "Subprefeitura Santo Amaro",
                                        "Subprefeitura Vila Mariana",
                                        "Subprefeitura Pinheiros"),
  ref_idrgp = c(0.0708, 0.0706, 0.0616, 0.0511, 0.0487, 0.0483, 0.0456, 0.0419,
                0.0406, 0.0377, 0.0374, 0.0364, 0.0353, 0.0346, 0.0346, 0.0291,
                0.0278, 0.0270, 0.0258, 0.0250, 0.0210, 0.0183, 0.0179, 0.0167,
                0.0157, 0.0150, 0.0150, 0.0146, 0.0113, 0.0094, 0.0086, 0.0068)) %>% 
  arrange(desc(ref_idrgp)))
```

### Base cartográfica do Município

Em seguida, inserimos a base cartográfica do município de São Paulo obtida a partir do GeoSampa.

A partir dela, selecionamos os dados das Subprefeituras com os valores de referência do índice.

```{r Cartografia, echo=FALSE, message=FALSE, warning=FALSE}
sp <- read_sf("SIRGAS_SHP_subprefeitura//SIRGAS_SHP_subprefeitura_polygon.shp")

subprefeitura <- sp %>% 
    rename(sigla = sp_sigla,
           NOME=sp_nome) %>% 
    select(NOME, sigla, geometry)
subprefeitura<- subprefeitura %>% 
   mutate(sp_nome = case_when(
    sigla %in% "AF" ~ "Subprefeitura Aricanduva/Formosa/Carrão",
    sigla %in% "BT" ~ "Subprefeitura Butantã",
    sigla %in% "CL" ~ "Subprefeitura Campo Limpo",
    sigla %in% "CS" ~ "Subprefeitura Capela do Socorro",
    sigla %in% "CV" ~ "Subprefeitura Casa Verde/Cachoeirinha",
    sigla %in% "AD" ~ "Subprefeitura Cidade Ademar",
    sigla %in% "CT" ~ "Subprefeitura Cidade Tiradentes",
    sigla %in% "EM" ~ "Subprefeitura Ermelino Matarazzo",
    sigla %in% "FO" ~ "Subprefeitura Freguesia/Brasilândia",
    sigla %in% "GU" ~ "Subprefeitura de Guaianases",
    sigla %in% "IP" ~ "Subprefeitura Ipiranga",
    sigla %in% "IT" ~ "Subprefeitura Itaim Paulista",
    sigla %in% "IQ" ~ "Subprefeitura Itaquera",
    sigla %in% "JA" ~ "Subprefeitura Jabaquara",
    sigla %in% "JT" ~ "Subprefeitura Jaçanã/Tremembé",
    sigla %in% "LA" ~ "Subprefeitura Lapa",
    sigla %in% "MB" ~ "Subprefeitura M'Boi Mirim",
    sigla %in% "MO" ~ "Subprefeitura Mooca",
    sigla %in% "PA" ~ "Subprefeitura Parelheiros",
    sigla %in% "PE" ~ "Subprefeitura Penha",
    sigla %in% "PR" ~ "Subprefeitura Perus/Anhanguera",
    sigla %in% "PI" ~ "Subprefeitura Pinheiros",
    sigla %in% "PJ" ~ "Subprefeitura Pirituba/Jaraguá",
    sigla %in% "ST" ~ "Subprefeitura Santana/Tucuruvi",
    sigla %in% "SA" ~ "Subprefeitura Santo Amaro",
    sigla %in% "SM" ~ "Subprefeitura São Mateus",
    sigla %in% "MP" ~ "Subprefeitura São Miguel Paulista",
    sigla %in% "SB" ~ "Subprefeitura Sapopemba",
    sigla %in% "SE" ~ "Subprefeitura Sé",
    sigla %in% "MG" ~ "Subprefeitura Vila Maria/Vila Guilherme",
    sigla %in% "VM" ~ "Subprefeitura Vila Mariana",
    TRUE ~ "Subprefeitura de Vila Prudente"))

subprefeitura <- inner_join(subprefeitura, ref_idrgp, by = "sp_nome")
#teste do mapa com siglas
subprefeitura %>% 
  ggplot() +
  geom_sf(aes(fill = ref_idrgp, geometry = geometry)) +
  scale_fill_gradient(low="red",high="blue") +
  geom_sf_text(aes(label = sigla), color = "black", size = 1.5, fontface = "bold") + 
  theme_void()

```



### Bases do PdM 2021-2024

Nesta seção, detalhamos os processos de obtenção e transformação dos dados de execução física e orçamentária do Programa de Metas. Para efeitos de monitoramento do IDRGP 2023, são considerados 28 compromissos do Programa de Metas 2021-2024 versão Alteração Programática. Tanto os dados de execução física quanto os da execução orçamentária são inseridos por cada órgão responsável no Sistema de Monitoramento e Acompanhamento Estratégico (SMAE).

Os dados de execução física são, nas metas selecionadas para o IDRGP 2023, desagregadas em nível regional (subprefeitura), podendo, dessa forma, serem extraídos diretamente do SMAE. Para tornar o presente relatório replicável, optou-se por utilizar como fonte sobre a execução física regionalizada os dados abertos do PdM, disponível em: \<[ ]().

Os dados de execução orçamentária correspondem à liquidação das dotações orçamentárias que abarcam despesas vinculadas ao Programa de Metas. Como os dados abertos apresentam os valores empenhados e, para fins de monitoramento do IDRGP, interessam os valores liquidados, extraiu-se um relatório do SMAE, em 04/03/2024, registrado nas abas "smae_x_da", do documento "metas_alteracao_programatica.xlsx". Para a desagregação regional destes dados, lançou-se mão de três estratégias:

-   Coleta de dados diretamente com os órgãos, nos casos das Metas 3, 4, 5, 7, 8, 9, 78 e 79, sob responsabilidade da Secretaria Municpal de Saúde (SMS) e da Meta 84, conduzida pela Secretaria Municipal de Cultura (SMC). Tais informações encontram-se na aba "totais_inf_orgaos", do documento "metas_alteracao_programatica.xlsx";
-   Cálculo da razão entre o valor liquidado e a execução física, por região, para a Meta 17;
-   Regionalização a partir do "Detalhamento da Ação", por meio de consulta a dados publicados pela Secretaria da Fazenda (SF). A base de dados da regionalização da execução orçamentária do exercício de 2023, pode ser extraída por meio do portal: \<[[https://orcamento.sf.prefeitura.sp.gov.br/orcamente/execucao.php\\\\](https://orcamento.sf.prefeitura.sp.gov.br/orcamente/execucao.php){.uri}](%5Bhttps://orcamento.sf.prefeitura.sp.gov.br/orcamente/execucao.php\%5D(https://orcamento.sf.prefeitura.sp.gov.br/orcamente/execucao.php)%7B.uri%7D){.uri}\>, nos formatos "[.csv](https://orcamento.sf.prefeitura.sp.gov.br/orcamento/uploads/2023/basedadosDA_1223.csv)", "[.xlsx](https://orcamento.sf.prefeitura.sp.gov.br/orcamento/uploads/2023/basedadosDA_1223.xlsx)", "[.ods](https://orcamento.sf.prefeitura.sp.gov.br/orcamento/uploads/2023/basedadosDA_1223.ods)" ou "[.json](https://orcamento.sf.prefeitura.sp.gov.br/orcamento/uploads/2023/basedadosDA_1223.json)"

Há casos em que a execução orçamentária da dotação foi integralmente dedicada ao Programa de Metas. Nesses casos, o valor regionalizado pelo detalhamento da ação corresponde ao valor regionalizado das metas consideradas para o IDRGP 2023.

Nos casos em que a dotação orçamentária não abarcou desepesas exclusivas do Programa de Metas, assumiu-se que a execução regionalizada da meta foi proporcional à regioanlização pelo detalhamento da ação.

Introduzidas as passagens que originaram os dados da execução física e orçamentária do Programa de Metas, apresentamos, a seguir, as manipulações para a criação de objetos necessários à análise dos dados, a começar pela importação e tratamentos preliminares.

```{r echo=FALSE}

#ler a aba totais_metas
base_smae <- read_excel("metas_alteracao_programatica.xlsx", sheet = "smae_x_da") %>%
  janitor::clean_names() %>%
  dplyr::select(idrgp:smae) %>% 
  rename(meta = no,
         txt_meta = descricao,
         dotacao = dotacoes_orcamentarias,
         total_smae = smae) %>%
    filter(idrgp == "S" & meta != 10 & total_smae > 0) %>% 
  select(-idrgp) %>% 
  distinct()

dotacao_smae <- unique(base_smae$dotacao)
soma_smae <- sum(base_smae$total_smae)
  
#ler a aba totais_metas_inf_orgaos
base_inf_orgaos <- readxl::read_excel("metas_alteracao_programatica.xlsx", sheet = "totais_metas_inf_orgaos") %>% 
  select("ORGAO":"Subprefeitura Vila Mariana") %>% 
  filter(TOTAL_SMAE > 0)

#transformar as colunas de subprefeituras e supra subprefeituras em uma única coluna
base_inf_orgaos <- base_inf_orgaos %>% 
    tidyr::pivot_longer(
      cols = c("Subprefeitura Aricanduva/Formosa/Carrão":"Subprefeitura Vila Mariana"),
      names_to = "subprefeitura",
      values_to = "valor_da_inf_orgao") %>%
  janitor::clean_names() %>% 
    dplyr::select(meta, dotacao, subprefeitura, valor_da_inf_orgao) %>% 
  filter(valor_da_inf_orgao > 0)

dotacao_inf_orgao <- unique(base_inf_orgaos$dotacao)
soma_inf_orgao <- sum(base_inf_orgaos$valor_da_inf_orgao)

## Identificar dotacoes incompletas da base_smae
base_smae %>% 
  select(dotacao) %>% 
  filter(str_length(dotacao) < 48) %>% 
  distinct()

# 7 casos
#1. 14.10.16.482.3005.3.355.44905100.00	
#2. 86.14.16.451.3002.3.357.44903900.03				
#3. 98.14.16.482.3002.3.340.44906100.08				
#4. 98.14.16.482.3002.3.354.44903900.08				
#5. 98.14.16.482.3002.3.354.44905100.08				
#6. 98.14.16.482.3005.3.355.44905100.08				
#7. 91.10.16.482.3002.3.356.44903900.08.1.759.8011

## Idetnificar dotacoes incompletas da base_inf_orgaos
base_inf_orgaos %>% 
  select(dotacao) %>% 
  filter(str_length(dotacao) < 48) %>% 
  distinct()

# 1 caso
#1. 25.10.13.392.3001.6.371.3390

## Com isso, será necessário:
### Tratar as dotações que possuem codificações incompletas nas bases smae e valor_inf_orgao
### Agrupar as dotações, para evitar relações muitos-para-muitos ao combinar bases de dados
### Mesclar as bases, separadamente, com a base do detalhamento da ação (visando evitar relações múltiplas entre bases)

```

O bloco, a seguir, demonstra o acesso à base do detalhamento da ação, disponibilizada pela Secretaria da Fazenda.

```{r echo=FALSE, paged.print=TRUE}

# obter base de dados do DA
bd_da <- unzip("basedadosDA_1223.zip", exdir = ".")
base_da <- readr::read_csv2(bd_da,
                          locale = locale(encoding = "latin1")) %>%
  janitor::clean_names() # extração em 15/05/2024, valores D-1 (portanto, 14/05/2024)

## também poderia ser baixado em "https://orcamento.sf.prefeitura.sp.gov.br/orcamento/uploads/2023/basedadosDA_1223.csv"
## 

base::names(base_da)

# criar coluna com a codificação da dotação orçamentária
base_da <- base_da %>% 
  dplyr::mutate(dotacao = base::paste(codigo_orgao,
                                      codigo_unidade,
                                      codigo_funcao,
                                      codigo_subfuncao,
                                      codigo_programa,
                                      codigo_proj_ativ,
                                      codigo_conta_despesa,
                                      codigo_fonte,
                                      codigo_exercicio_fonte,
                                      codigo_destinacao_recurso,
                                      codigo_vinculo_pmsp,
                                      codigo_tipo_credito_orcamentario,
                                      sep = "."),
                dotacao = base::sub('^(.{19})', '\\1.', dotacao)) 

base_da1 <- base_da %>% 
  dplyr::select(dotacao, sigla_orgao, regiao, subprefeitura, distrito, tipo_regionalizacao, valor_detalhamento_acao) %>%   dplyr::group_by(dotacao, subprefeitura) %>% 
  dplyr::summarise(sigla_orgao = first(sigla_orgao),
                   regiao = first(regiao),
                   subprefeitura = first(subprefeitura),
                   distrito = first(distrito),
                   tipo_regionalizacao = first(tipo_regionalizacao),
                   valor_detalhamento_acao = sum(valor_detalhamento_acao)) %>% 
  dplyr::filter(tipo_regionalizacao == "Despesa Regionalizável")


# checar existência de NA
base_da1 %>%
  summarise_all(~ any(is.na(.))) #não há NA

# transformar subprefeitura=="Supra Subprefeitura Centro" em "Subprefeitura Sé"
base_da1 <- base_da1 %>% 
  mutate(subprefeitura = case_when(
    subprefeitura %in% "Supra Subprefeitura Centro" ~ "Subprefeitura Sé",
    TRUE ~ subprefeitura)
  )

base_da1 <- base_da1 %>% 
  select(dotacao, subprefeitura, regiao, sigla_orgao, valor_detalhamento_acao)

soma_da_base1 <- sum(base_da1$valor_detalhamento_acao)

```

Tendo acesso ao universo de dotações regionalizadas que tiveram execução em 2023, vamos prosseguir com o tratamento das dotações incompletas das bases smae e valor_inf_orgao
```{r include=FALSE}

# O tratamento das dotações incompletas consiste em ratear o valor total_smae conforme a proporção de cada dotação completa contida no agruamento da dotação incompleta. O produto final será a base_smae com dotacoes equiráveis à base_da1, mas com os valores total_smae ajustados proporcionalmente.

colnames(base_smae)

# 7 casos
#1. 14.10.16.482.3005.3.355.44905100.00	
#2. 86.14.16.451.3002.3.357.44903900.03				
#3. 98.14.16.482.3002.3.340.44906100.08				
#4. 98.14.16.482.3002.3.354.44903900.08				
#5. 98.14.16.482.3002.3.354.44905100.08				
#6. 98.14.16.482.3005.3.355.44905100.08				
#7. 91.10.16.482.3002.3.356.44903900.08.1.759.8011

#1. 25.10.13.392.3001.6.371.3390


#1 14.10.16.482.3005.3.355.44905100.00
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^14\\.10\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.00") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^14\\.10\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.00")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae) # diferença é insignificante; para ajustar as checagens vou diminuir esse valor da dotação linha com maior valor liquidado

d <- sum(b$total_smae) - sum(c$total_smae)

c <- c %>% 
  arrange(desc(total_smae))

c$total_smae[1] <- c$total_smae[1] + d

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^14\\.10\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.00"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c", "d"))


#2 86.14.16.451.3002.3.357.44903900.03
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03")& str_length(dotacao) < 48) %>% 
  select(-dotacao) #neste caso, há duas metas. Vamos ajustar uma de cada vez

b <- base_smae %>% 
  filter(str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03")&
           str_length(dotacao) < 48 &
           meta == 12) %>% 
  select(-dotacao) #neste caso, há duas metas. Vamos ajustar uma de cada vez

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!(meta == 12 & str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03")))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("b", "c"))

b <- base_smae %>% 
  filter(str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03")&
           str_length(dotacao) < 48 &
           meta == 13) %>% 
  select(-dotacao) #neste caso, há duas metas. Vamos ajustar uma de cada vez

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!(meta == 13 & str_detect(dotacao, "^86\\.14\\.16\\.451\\.3002\\.3\\.357\\.44903900\\.03")))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c"))


#3 98.14.16.482.3002.3.340.44906100.08 
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.340\\.44906100\\.08") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.340\\.44906100\\.08")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.340\\.44906100\\.08"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c"))


#4 98.14.16.482.3002.3.354.44903900.08	
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44903900\\.08") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44903900\\.08")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44903900\\.08"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c"))


#5 98.14.16.482.3002.3.354.44905100.08	
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44905100\\.08") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44905100\\.08")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^98\\.14\\.16\\.482\\.3002\\.3\\.354\\.44905100\\.08"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c"))


#6 98.14.16.482.3005.3.355.44905100.08	
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.08") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^98\\.14\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.08")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^98\\.14\\.16\\.482\\.3005\\.3\\.355\\.44905100\\.08"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c"))


#7 91.10.16.482.3002.3.356.44903900.08.1.759.8011 
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^91\\.10\\.16\\.482\\.3002\\.3\\.356\\.44903900\\.08\\.1\\.759\\.8011") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_smae %>% 
  filter(str_detect(dotacao, "^91\\.10\\.16\\.482\\.3002\\.3\\.356\\.44903900\\.08\\.1\\.759\\.8011")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  orgao = rep(unique(b$orgao), rep),
  meta = rep(unique(b$meta), rep),
  txt_meta = rep(unique(b$txt_meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  total_smae.x = rep(b$total_smae, each = nrow(a)),
  total_smae.y = total_smae.x*prop) %>%
  rename(total_smae = total_smae.y) %>% 
  select(-prop, -total_smae.x)

sum(b$total_smae) == sum(c$total_smae)
sum(b$total_smae) - sum(c$total_smae)

base_smae <- base_smae %>% 
  filter(!str_detect(dotacao, "^91\\.10\\.16\\.482\\.3002\\.3\\.356\\.44903900\\.08\\.1\\.759\\.8011"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_smae <- base_smae %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c", "rep"))

(checagem1 <- soma_smae == sum(base_smae$total_smae))


#1. 25.10.13.392.3001.6.371.3390 
(a <- base_da1 %>% 
  filter(str_detect(dotacao, "^25\\.10\\.13\\.392\\.3001\\.6\\.371\\.3390") & valor_detalhamento_acao > 0) %>% 
  group_by(dotacao) %>% 
  summarise(valor_detalhamento_acao = sum(valor_detalhamento_acao), .groups = "drop") %>% 
  mutate(total_valor = sum(valor_detalhamento_acao),
         prop = valor_detalhamento_acao / total_valor)) %>% 
  select(-total_valor)# para identificar quantas dotações são abragidas pela dotação incompleta calcular a proporção de cada dotação completa no conjunto abrangido pela dotação incompleta

b <- base_inf_orgaos %>% 
  filter(str_detect(dotacao, "^25\\.10\\.13\\.392\\.3001\\.6\\.371\\.3390")& str_length(dotacao) < 48) %>% 
  select(-dotacao)

rep <- nrow(a) * nrow(b)

c <- tibble(
  meta = rep(unique(b$meta), rep),
  dotacao = rep(a$dotacao, nrow(b)),
  prop = rep(a$prop, nrow(b)),
  subprefeitura = rep(unique(b$subprefeitura), each = nrow(a)),
  valor_da_inf_orgao.x = rep(b$valor_da_inf_orgao, each = nrow(a)),
  valor_da_inf_orgao.y = valor_da_inf_orgao.x*prop) %>%
  rename(valor_da_inf_orgao = valor_da_inf_orgao.y) %>% 
  select(-prop, -valor_da_inf_orgao.x)

sum(b$valor_da_inf_orgao) == sum(c$valor_da_inf_orgao)
sum(b$valor_da_inf_orgao) - sum(c$valor_da_inf_orgao)

base_inf_orgaos <- base_inf_orgaos %>% 
  filter(!str_detect(dotacao, "^25\\.10\\.13\\.392\\.3001\\.6\\.371\\.3390"))#para remover todos os registros com a dotação em questão (evitar duplicidades)

base_inf_orgaos <- base_inf_orgaos %>% 
  bind_rows(c) # para ter registros com dotações completas

rm(list = c("a", "b", "c", "rep"))

(checagem2 <- soma_inf_orgao == sum(base_inf_orgaos$valor_da_inf_orgao))

# Como as bases serão combinadas com outras, em especial a do detalhamento da ação, é importante garantir que as bases tenham linhas exclusivas. Na base_smae, é necessário fazer o agrupamento de dotações.

(base_smae <- base_smae %>% 
  group_by(dotacao) %>% 
  summarise(orgao = first(orgao),
            meta = first(meta),
            txt_meta = first(txt_meta),
            total_smae = sum(total_smae)) %>% 
  select(orgao, meta, txt_meta, dotacao, total_smae) %>% 
  arrange(meta, dotacao))

dotacao_smae <- unique(base_smae$dotacao)
dotacao_inf_orgao <- unique(base_inf_orgaos$dotacao)

```

As bases base_smae e base_inf_orgaos estão prontas para serem mescladas. É necessário, agora, tratar a base_da1, distribuindo os valores cuja regionalização foi apontada como sendo supra regional para as subprefeituras que compõem cada região. Após esse procedimento, vamos calcular a proporção gasta em cada região para ter como resultado uma das estratégias de obtenção do valor regionalizado dos recursos liquidados nas ações do Programa de Metas, monitorados no IDRGP.

```{r include=FALSE}

## Ratear valores de subprefeitura=="Supra Subprefeitura Região X" nas respectivas subprefeituras da Região X
suporte_rateio_regioes <- base_da1 %>% 
  filter(subprefeitura %in% c("Supra Subprefeitura Leste",
                          "Supra Subprefeitura Norte",
                          "Supra Subprefeitura Oeste",
                          "Supra Subprefeitura Sul")) #df apenas do que tem "supra" na coluna dotacao

sum(suporte_rateio_regioes$valor_detalhamento_acao) #441164215

(n_sub_regioes <- base_da1 %>% 
  filter(!str_detect(subprefeitura, "Supra")) %>% 
  group_by(regiao) %>% 
  summarise(count = n_distinct(subprefeitura))) #número de subprefeituras por região

(suporte_rateio_regioes <- suporte_rateio_regioes %>% 
  left_join(n_sub_regioes, by = "regiao") %>% 
  mutate(valor_rateio = valor_detalhamento_acao / count) %>% 
  arrange(dotacao))

sum(suporte_rateio_regioes$valor_rateio) #64756605

(suporte_rateio_regioes <- suporte_rateio_regioes %>% 
    select(-subprefeitura))

(teste <- base_da1 %>%
  left_join(suporte_rateio_regioes, by = intersect(names(base_da1), names(suporte_rateio_regioes))) %>% 
  replace_na(list(count = 0, valor_rateio = 0)) %>% 
    distinct())

(checagem3 <- sum(teste$valor_rateio, na.rm = TRUE)== sum(suporte_rateio_regioes$valor_detalhamento_acao)) #Como existem dotações que são apenas supra regionais, era esperado que a equivalência proposta por esta checagem não ocorresse

rm("teste")

# criar objeto complementar comp_sub_dot com todas as combinações de dotações e subprefeituras
a <- base_da1

comp_sub_dot <- expand_grid(dotacao = unique(base_da1$dotacao),
                 subprefeitura = unique(a$subprefeitura))

rm(a)

# acrescentar regiao ao objeto comp_sub_dot
(comp_sub_dot <- comp_sub_dot %>% 
  mutate(regiao = case_when(
    subprefeitura %in% c("Subprefeitura Aricanduva/Formosa/Carrão",
                   "Subprefeitura Cidade Tiradentes",
                   "Subprefeitura de Guaianases",
                   "Subprefeitura de Vila Prudente",
                   "Subprefeitura Ermelino Matarazzo",
                   "Subprefeitura Itaim Paulista",
                   "Subprefeitura Itaquera",
                   "Subprefeitura Mooca",
                   "Subprefeitura Penha",
                   "Subprefeitura São Mateus",
                   "Subprefeitura São Miguel Paulista",
                   "Subprefeitura Sapopemba",
                   "Supra Subprefeitura Leste") ~ "Leste",
    subprefeitura %in% c("Subprefeitura Butantã",
                   "Subprefeitura Lapa",
                   "Subprefeitura Pinheiros",
                   "Supra Subprefeitura Oeste") ~ "Oeste",
    subprefeitura %in% c("Subprefeitura Casa Verde/Cachoeirinha",
                   "Subprefeitura Freguesia/Brasilândia",
                   "Subprefeitura Jaçanã/Tremembé",
                   "Subprefeitura Perus/Anhanguera",
                   "Subprefeitura Pirituba/Jaraguá",
                   "Subprefeitura Santana/Tucuruvi",
                   "Subprefeitura Vila Maria/Vila Guilherme",
                   "Supra Subprefeitura Norte") ~ "Norte",
    subprefeitura %in% c("Subprefeitura Sé",
                   "Supra Subprefeitura Centro") ~ "Centro",
    TRUE ~ "Sul")))

#acrescentar sigla_orgao
(a <- base_da1 %>% 
    select(c("dotacao", "sigla_orgao")))

comp_sub_dot <- comp_sub_dot %>% 
  left_join(a, by = "dotacao") %>% 
  distinct()

rm(a)

#juntar valor_detalhamento_acao
a <- comp_sub_dot %>% 
  left_join(base_da1, by = intersect(names(comp_sub_dot), names(base_da1))) %>% 
  distinct() %>% 
  replace_na(list(valor_detalhamento_acao = 0))

(checagem4 <- sum(a$valor_detalhamento_acao) == soma_da_base1) 

comp_sub_dot <- a

rm(list = c("a", "b", "c"))

# Checar se todas as dotações possuem contagem 36 para subprefeitura (32 subs + 4 supra)
(a <- comp_sub_dot %>% 
  select(dotacao, regiao, subprefeitura) %>% 
  group_by(dotacao) %>% 
  summarise(checagem = n_distinct(subprefeitura)))

a %>% 
  filter(checagem < 36)

rm(a)

#juntar count e valor_rateio
a <- comp_sub_dot %>% 
  left_join(suporte_rateio_regioes, by = c("dotacao", "regiao", "sigla_orgao")) %>% 
  distinct() %>% 
  replace_na(list(valor_detalhamento_acao.y = 0, count = 0, valor_rateio = 0))

colnames(a)

sum(a$valor_detalhamento_acao.x)
sum(a$valor_detalhamento_acao.y, na.rm = TRUE)
sum(a$valor_rateio)

(b <- a %>% 
  filter(dotacao == "04.10.15.452.3011.2.300.33903000.06.1.501.9001.0"))

b %>% 
  filter(!str_detect(subprefeitura, "Supra")) %>% 
  select(regiao, valor_rateio) %>% 
  group_by(regiao) %>% 
  summarise(sum(valor_rateio))

a <- a %>% 
  mutate(valor_detalhamento_acao = valor_detalhamento_acao.x + valor_rateio) %>% 
  filter(!str_detect(subprefeitura, "Supra"))

a <- a %>% 
  filter(valor_detalhamento_acao > 0) %>% 
  select(dotacao, subprefeitura, regiao, sigla_orgao, valor_detalhamento_acao)

comp_sub_dot <- a

rm(list = c("a"))

# acrescentar o gasto proporcial em cada região; em cada dotação
a <- comp_sub_dot %>% 
  group_by(dotacao) %>% 
  mutate(total_valor = sum(valor_detalhamento_acao))

a <- a %>% 
  mutate(proporcao = valor_detalhamento_acao/total_valor)

# Checagem se todos os agrupamentos de dotação somam 100%
(b <- a %>% 
  group_by(dotacao) %>% 
  summarise(chec = sum(proporcao)) %>% 
  filter(chec != 1))

comp_sub_dot <- a %>% 
  select(-total_valor)

rm(list = c("a", "b"))

```

Agora, inserimos informações sobre as execuções física e orçamentária do Programa de Metas, combinando as bases: base_smae, base_inf_orgaos e comp_sub_dot. Também trabalhamos com as informações sobre a execução física regionalizada do Programa de Metas. Com isso, chegamos a uma base com as três estratégias de regionalização da execução orçamentária das metas, a saber: regionalização pelo DA (ou proporção); informação direta do órgão e estimativa a partir da razão entre valor liquidado e execução física.
```{r include=FALSE}

##### Criação da base_da_pdm - join base_da, base_smae, base_inf_orgaos #####

# Criar uma base, a partir de com_sub_dot apenas com dotações do PdM
base_da_pdm <- comp_sub_dot %>% 
  filter(dotacao %in% dotacao_smae)

soma_base_da_pdm <- sum(base_da_pdm$valor_detalhamento_acao)

# Combinar bases da_pdm e smae

chave_da <- base_da1 %>% 
  select(dotacao, valor_detalhamento_acao) %>% 
  group_by(dotacao) %>% 
  summarise(chave_da = sum(valor_detalhamento_acao))  #Vamos adicionar o valor do detalhamento da ação da dotdação, para ter uma chave a mais de conexão entre as bases smae e da_pdm

a <- base_da_pdm %>% 
  left_join(chave_da, by = "dotacao") # acrescentando chave na base_da_pdm

b <- base_smae %>% 
  left_join(chave_da, by = "dotacao") # acrescentando chave na base_smae

c <- a %>% 
  left_join(b, by = c("dotacao", "chave_da")) %>% 
  distinct() %>% 
  replace_na(list(total_smae = 0, valor_detalhamento_acao = 0, proporcao = 0)) %>% 
  mutate(acao_orcamentaria = substr(dotacao, 19, 23)) %>% 
  select(meta, txt_meta, dotacao, acao_orcamentaria, orgao, sigla_orgao, regiao, subprefeitura, proporcao, chave_da, valor_detalhamento_acao, total_smae) %>% 
  arrange(meta, dotacao)   

#checagens
(d <- c %>% 
  group_by(dotacao, meta) %>% 
  summarise(chec = mean(total_smae)))

(e <- c %>% 
  group_by(dotacao) %>% 
  summarise(chec = mean(chave_da)))

(checagem8 <- sum(d$chec) == soma_smae)
sum(d$chec)
soma_smae - sum(d$chec)

(checagem9 <- sum(e$chec) == soma_base_da_pdm)

# Para investigar a diferença da checagem 8, vamos criar uma tabela com meta, valor smae da base b e valor smae da base smae, agrupados por meta. Dessa forma, será possível indentificar em qual meta há discrepância

f <- base_smae %>% 
  group_by(meta) %>% 
  summarise(b_smae = sum(total_smae))

g <- c %>% 
  group_by(meta, dotacao) %>% 
  summarise(b_da = mean(total_smae))

h <- g %>% 
  group_by(meta) %>% 
  summarise(b_da = sum(b_da))

i <- f %>% 
  full_join(h, by = "meta") %>% 
  mutate(dif =  b_da - f$b_smae) %>% 
  filter(dif != 0) # a diferença se concentra na meta 4

j <- c %>% 
  filter(meta == 4) %>% 
  group_by(acao_orcamentaria)

dot_m4_da <- unique(j$dotacao)

k <- base_smae %>% 
  filter(meta == 4) %>% 
  group_by(dotacao)

dot_m4_smae <- unique(k$dotacao)

(dot_m4 <- setdiff(dot_m4_smae, dot_m4_da))

base_da1 %>% 
  filter(dotacao %in% dot_m4) # 0

base_da %>% 
  filter(dotacao %in% dot_m4) # A diferença refere-se a despesas não regionalizáveis

# Como não é possível sanar esta diferença, vamos considerar que a soma do valor smae é o da base_da_pdm

base_da_pdm <- c

soma_smae.x <- sum(d$chec)

# checando se todas as proporções somam 1
l <- c %>% 
  group_by(dotacao) %>% 
  summarise(prop = sum(proporcao)) %>% 
  distinct() %>% 
  filter(prop != 1) # Há diferenças apenas nas casas decimais

rm("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "chave_da")


# Mesclar base_inf_orgaos
base_da_pdm <- base_da_pdm %>% 
  left_join(base_inf_orgaos, by = intersect(names(base_da_pdm), names(base_inf_orgaos))) %>% 
  replace_na(list(valor_da_inf_orgao = 0))


##### Acréscimo de valor de exec_fisica ####

# acrescentar valor de exec_fisica

#seguir o caminho abaixo (desabilitado), baixando diretamente do  site, ou aqui:
base_exec_fisica <- readxl::read_excel("Relatório de Execução Anual do Programa de Metas 2021-2024 (Abril2024) (1).xlsx", sheet = "principal", skip = 2) %>% 
    janitor::clean_names()

#url_balanco <-  "https://www.prefeitura.sp.gov.br/cidade/secretarias/upload/governo/planejamento/Relat%C3%B3rio%20de%20Execu%C3%A7%C3%A3o%20Anual%20do%20Programa%20de%20Metas%202021-2024%20(Abril2024).xlsx" #note que o documento é de abril. Caso o documento seja atualizado, necessário alterar o link

#response <- httr::GET(url_balanco) # Fazendo a solicitação GET

#content <- httr::content(response, as = "raw") # Extraindo o conteúdo da resposta como um objeto raw

t#emp_file <- tempfile(fileext = ".xlsx") # Criando um arquivo temporário para armazenar o conteúdo

#writeBin(content, temp_file) # Escrevendo o conteúdo no arquivo temporário

#(base_exec_fisica <- readxl::read_excel(temp_file, sheet = "principal", skip = 2) %>% 
#    janitor::clean_names())

(base_exec_fisica <- base_exec_fisica %>% 
  rename(meta = x1,
         txt_meta = x2,
         indicador = x3,
         objetivo_estrategico = x4,
         iniciativas = x5,
         eixo = x6,
         ods = x7,
         orgao = x8)) #necessário ajustar o padrão de pontuação (ora milhares está separado por "." ora por "," ora está sem separação)


#(base_exec_fisica_reg <- readxl::read_excel(temp_file, sheet = "regionalização", skip = 1) %>% 
 #   janitor::clean_names())
base_exec_fisica_reg <- readxl::read_excel("Relatório de Execução Anual do Programa de Metas 2021-2024 (Abril2024) (1).xlsx", sheet = "regionalização", skip = 1) %>% 
    janitor::clean_names()

(base_exec_fisica_reg <- base_exec_fisica_reg %>% 
  rename(meta = x1,
         subprefeitura = x2)) # necessário padronizar nomes das subprefeituras conforme base_pdm_completa e preencher coluna meta, cujas células estão mescladas na planilha original


# Padronizar nome das subprefeituras conforme base_da_pdm
(base_exec_fisica_reg <- base_exec_fisica_reg %>% 
  mutate(subprefeitura = case_when(
           subprefeitura %in% "Aricanduva" ~ "Subprefeitura Aricanduva/Formosa/Carrão",
           subprefeitura %in% "Butantã" ~ "Subprefeitura Butantã",
           subprefeitura %in% "Campo Limpo" ~ "Subprefeitura Campo Limpo",
           subprefeitura %in% "Capela do Socorro" ~ "Subprefeitura Capela do Socorro",
           subprefeitura %in% "Casa Verde" ~ "Subprefeitura Casa Verde/Cachoeirinha",
           subprefeitura %in% "Cidade Ademar" ~ "Subprefeitura Cidade Ademar",
           subprefeitura %in% "Cidade Tiradentes" ~ "Subprefeitura Cidade Tiradentes",
           subprefeitura %in% "Ermelino Matarazzo" ~ "Subprefeitura Ermelino Matarazzo",
           subprefeitura %in% "Freguesia/Brasilândia" ~ "Subprefeitura Ermelino Matarazzo",
           subprefeitura %in% "Guaianases" ~ "Subprefeitura de Guaianases",
           subprefeitura %in% "Ipiranga" ~ "Subprefeitura Ipiranga",
           subprefeitura %in% "Itaim Paulista" ~ "Subprefeitura Ipiranga",
           subprefeitura %in% "Itaquera" ~ "Subprefeitura Itaquera",
           subprefeitura %in% "Jabaquara" ~ "Subprefeitura Itaquera",
           subprefeitura %in% "Jaçanã/Tremembé" ~ "Subprefeitura Jaçanã/Tremembé",
           subprefeitura %in% "Lapa" ~ "Subprefeitura Lapa",
           subprefeitura %in% "M'Boi Mirim" ~ "Subprefeitura M'Boi Mirim",
           subprefeitura %in% "Mooca" ~ "Subprefeitura Mooca",
           subprefeitura %in% "Parelheiros" ~ "Subprefeitura Parelheiros",
           subprefeitura %in% "Penha" ~ "Subprefeitura Penha",
           subprefeitura %in% "Perus/Anhanguera" ~ "Subprefeitura Perus/Anhanguera",
           subprefeitura %in% "Pinheiros" ~ "Subprefeitura Pinheiros",
           subprefeitura %in% "Pirituba/Jaraguá" ~ "Subprefeitura Pirituba/Jaraguá",
           subprefeitura %in% "Santana/Tucuruvi" ~ "Subprefeitura Santana/Tucuruvi",
           subprefeitura %in% "Santo Amaro" ~ "Subprefeitura Santo Amaro",
           subprefeitura %in% "São Mateus" ~ "Subprefeitura São Mateus",
           subprefeitura %in% "São Miguel Paulista" ~ "Subprefeitura São Miguel Paulista",
           subprefeitura %in% "Sapopemba" ~ "Subprefeitura Sapopemba",
           subprefeitura %in% "Sé" ~ "Subprefeitura Sé",
           subprefeitura %in% "Vila Maria/Vila Guilherme" ~ "Subprefeitura Vila Maria/Vila Guilherme",
           subprefeitura %in% "Vila Mariana" ~ "Subprefeitura Vila Mariana",
           TRUE ~ "Subprefeitura de Vila Prudente")))

# Substituir NA na coluna meta
(base_exec_fisica_reg <- base_exec_fisica_reg %>% 
  fill(meta, .direction = "down"))

# Selecionar apenas as colunas meta, subprefeitura e x2023, e apenas metas consideradas para o IDRGP

(readxl::excel_sheets("metas_alteracao_programatica.xlsx"))

metas_idrgp <- read_excel("metas_alteracao_programatica.xlsx", sheet = "metas") %>%
  janitor::clean_names() %>% 
  rename(meta = no) %>% 
    filter(meta != 10) %>% 
  select(meta)

(metas_idrgp <- unique(metas_idrgp))

(metas_idrgp <- unique(base_smae$meta)) # metas 27, 53, 79 não tiveram execução orçamentária

(base_exec_fisica_reg_23 <- base_exec_fisica_reg %>% 
  select(meta, subprefeitura, x2023)) 

glimpse(base_exec_fisica_reg_23) # ao observar o df, percebemos que a coluna x2023 é chr e alguns registros e as casas decimais estão separadas por "," e não por "." (ex: base_exec_fisica_reg_23$x2023[202]), sendo necessário substituí-los para que não se tornem NA ao executar o comando as.numeric

(base_exec_fisica_reg_23 <- base_exec_fisica_reg_23 %>% 
  mutate(x2023 = gsub(",", ".", x2023)))

(base_exec_fisica_reg_23$x2023 <- as.numeric(base_exec_fisica_reg_23$x2023))

base_exec_fisica_reg %>% 
  select(meta, subprefeitura, x2023) %>% 
  filter(meta %in% c("27", "53", "79")) # Houve execução física para as metas 27 e 79, porém não há elementos para atribuir valores às subprefeituras

(base_exec_fisica_reg_23 <- base_exec_fisica_reg_23 %>% 
  filter(meta %in% metas_idrgp) %>% 
    rename(exec_fisica = x2023)) # Vamos, então, selecionar apenas as metas consideradas para o monitoramento do IDRGP


# Juntar com base_da_pdm
(a <- base_da_pdm %>% 
  left_join(base_exec_fisica_reg_23, by = c("meta", "subprefeitura")) %>% 
  distinct() %>% 
    replace_na(list(exec_fisica = 0)))

(b <- a %>% 
  group_by(dotacao, meta) %>% 
  summarise(chec = mean(total_smae)))

(c <- a %>% 
  group_by(dotacao) %>% 
  summarise(chec = sum(valor_detalhamento_acao)))

(checagem8 <- sum(b$chec) == soma_smae.x)

(checagem9 <- sum(c$chec) == soma_base_da_pdm)

d <- a %>% 
  group_by(dotacao) %>% 
  summarise(prop = sum(proporcao)) %>% 
  distinct() %>% 
  filter(prop != 1) %>% 
  arrange(desc(prop))

a %>% 
  filter(dotacao == "84.10.10.301.3003.2.520.44505200.00.1.500.7034.1") #c omo o join entre base_exec_reg_23 e base_da_pdm ampliou o número de linhas, será necessário recalcular a coluna proporcao

a <- a %>% 
  group_by(dotacao) %>% 
  mutate(proporcao = valor_detalhamento_acao / sum(valor_detalhamento_acao))

e <- a %>% 
  group_by(dotacao) %>% 
  summarise(prop = sum(proporcao)) %>% 
  distinct() %>% 
  filter(prop != 1) %>% 
  arrange(desc(prop))      # diferença nas casas decimais

base_da_pdm <- a


##### Aplicação de proporções (regionais) ao total_smae ####

# recalcular o total_smae, distribuindo os valores por regiões
a <- base_da_pdm %>% 
  mutate(total_smae.p = total_smae*proporcao)

Checagem10 <- sum(a$total_smae.p) == soma_smae.x

a <- a %>% 
  select(-chave_da, -proporcao, -total_smae) %>% 
  mutate(estimativa = if_else(exec_fisica == 0, 0, total_smae.p / exec_fisica))

a <- a %>% 
  mutate(valor_liquidado = case_when(
    meta == 17 ~ estimativa,
    orgao %in% c("SMS", "SMC") ~ valor_da_inf_orgao,
    TRUE ~ total_smae.p
  ))

sum(a$valor_liquidado)

a <- a %>% 
  rename(total_smae = total_smae.p) %>% 
  select(meta, txt_meta, dotacao, acao_orcamentaria, orgao, sigla_orgao, subprefeitura, exec_fisica, valor_detalhamento_acao, valor_da_inf_orgao, estimativa, total_smae, valor_liquidado)

base_da_pdm <- a

rm(list = c("a", "b", "c", "d", "e", "response", "content", "temp_file", "url_balanco"))

```

Com a base ajustada, faremos manipulações para explorar os dados e visualizações

```{r echo=FALSE}

##### Se o IDRGP fosse composto apenas pelo PdM, como seria a situação em 20203? ####

gp_idrgp_pdm <- base_da_pdm %>% 
  group_by(subprefeitura) %>% 
  summarise(valor_liquidado = sum(valor_liquidado)) %>% 
  rename(sp_nome = subprefeitura) %>% 
  left_join(ref_idrgp, by = "sp_nome") %>% 
  mutate(g_perc = valor_liquidado / sum(valor_liquidado),
         diferenca = g_perc - ref_idrgp) %>% 
  arrange(desc(ref_idrgp))

gp_idrgp_pdm %>% 
  mutate("Status" = case_when(
    gp_idrgp_pdm$diferenca < 0 ~ "Execução MENOR do que a referência pelo IDRGP",
    gp_idrgp_pdm$diferenca >= 0 ~ "Execução MAIOR do que a referência pelo IDRGP"
  )) %>% 
  ggplot() +
  geom_col(aes(x = g_perc,
               y = forcats::fct_reorder(sp_nome, ref_idrgp),
               fill = Status),
           show.legend = TRUE) +
  scale_fill_manual(values = c("#0A447F", "orange")) +
  scale_x_continuous(name = NULL,
                     labels = scales::comma_format(big.mark = ".",
                                                   decimal.mark = ",")) +
  geom_point(mapping = aes(x = ref_idrgp,
                           y = sp_nome,
                           colour = "Referência pelo IDRGP"),
             show.legend = TRUE) +
  labs(title = "IDRGP PdM 2023",
       y = "") +
  theme_minimal()+
  theme(legend.title = element_blank(),
        legend.position = "bottom")

##### Como os valores liquidados do PdM se distribuiram territorialmente? ####

a <- gp_idrgp_pdm %>% 
  left_join(subprefeitura, by = c("sp_nome", "ref_idrgp")) %>% 
  st_as_sf()

str(a)

ggplot(data = a) +
  geom_sf(aes(fill = g_perc, geometry = geometry)) +
  geom_sf_text(aes(label = sigla), color = "black", size = 1.5, fontface = "bold") + 
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  theme_void()


##### Quais orgãos tiveram maior valor_liquidado em 2023? ####

b <- base_da_pdm %>% 
  group_by(orgao) %>% 
  summarise(valor_liquidado = sum(valor_liquidado)) %>% 
  arrange(desc(valor_liquidado))

b %>% 
  ggplot() +
   geom_col(aes(x = valor_liquidado,
               y = forcats::fct_reorder(orgao, valor_liquidado)))


##### Quais políticas públicas (ações orçamentárias) tiveram mais recursos liquidados? ####

c <- base_da_pdm %>% 
  group_by(acao_orcamentaria) %>% 
  summarise(valor_liquidado = sum(valor_liquidado)) %>% 
  arrange(desc(valor_liquidado))

c %>% 
  ggplot() +
   geom_col(aes(x = valor_liquidado,
               y = forcats::fct_reorder(acao_orcamentaria, valor_liquidado)))



```

### Adicionando a base de Obras Prioritárias

Para gerar a base de Obras Priotirárias, iremos abrir a base encaminhada pela Unidade de Entregas da SEPEP, padronizar nomes e realizar filtros, como os que removem obras de mobilidade e macrodrenagem, bem como “Requalificação”, “Restauro” e “Manutenção” com valores inferiores a um milhão de reais, pois estas obras não compõem  o cálculo do IDRGP.


```{r Limpando a base de obras prioritárias, message=FALSE, warning=FALSE, include=FALSE}
 
op <- read_xlsx("base_monitoramento_obras_2.xlsx")
op <- op %>% 
  filter(`Meta PdM`== "Não", valor_liquidado_2023>0)

op <- op %>% 
  mutate(analise = ifelse(`Tipo de obra/intervenção`== "Requalificação", "analisar", NA ),
         analise = ifelse(`Tipo de obra/intervenção`== "Restauro", "analisar", analise),
         analise = ifelse(`Tipo de obra/intervenção`== "Manutenção", "analisar", analise),
         analise = ifelse(`Tipo de obra/intervenção`== "Requalificação ", "analisar", analise ))
op <- op %>% 
  mutate(decisão1 = ifelse(`Tipo de obra/intervenção`== "Requalificação" & valor_liquidado_2023<1000000, "excluir", "manter"))
op <- op %>% 
  mutate(decisão2 = ifelse(`Tipo de obra/intervenção`== "Restauro" & valor_liquidado_2023<1000000, "excluir", "manter"))
op <- op %>% 
  mutate(decisão3 = ifelse(`Tipo de obra/intervenção`== "Manutenção" & valor_liquidado_2023<1000000, "excluir", "manter"))
op <- op %>% 
  mutate(decisão4 = ifelse(`Tipo de obra/intervenção`== "Requalificação " & valor_liquidado_2023<1000000, "excluir", "manter"))
op <- op %>%
  filter(decisão1=="manter" & decisão2=="manter" & decisão3== "manter" & decisão4=="manter")

op<- op %>% 
  mutate(macrod1 = str_detect(`Obra/Intervenção`, "Córrego", FALSE))
op<- op %>% 
  mutate(macrod2 = str_detect(`Obra/Intervenção`, "Piscinão", F))
op<- op %>% 
  mutate(macrod3 = str_detect(`Obra/Intervenção`, "Reservatório", F))
op<- op %>% 
  mutate(macrod4 = str_detect(`Obra/Intervenção`, "Canalização", F))
op <- op %>%
  filter(macrod1==F & macrod2== F & macrod3== F & macrod4== F)

#removendo obras viárias (mobilidade)
op<- op %>% 
  mutate(obraviaria = str_detect(`Obra/Intervenção`, "Viária", F)) %>% 
  filter(obraviaria==F)

op <- op %>% 
  mutate(Subprefeitura = ifelse(Subprefeitura == "Aricanduva/Carrão/Formosa", "Aricanduva/Formosa/Carrão", Subprefeitura))
op <- op %>% 
  filter(Secretaria != "SMT", Subprefeitura != "Várias") %>% 
  mutate(acao_orcamentaria = str_replace(`Cod projeto`,"^(.{1})(.*)$",  "\\1.\\2"),
         id= `...1`) %>%
  select(id, `Obra/Intervenção`, acao_orcamentaria,  Secretaria, Subprefeitura, valor_liquidado_2023)

op<- op %>% 
   mutate("sp_nome" = case_when(
    Subprefeitura %in% "Aricanduva/Formosa/Carrão" ~ "Subprefeitura Aricanduva/Formosa/Carrão",
    Subprefeitura %in% "Butantã" ~ "Subprefeitura Butantã",
    Subprefeitura %in% "Campo Limpo" ~ "Subprefeitura Campo Limpo",
    Subprefeitura %in% "Capela do Socorro" ~ "Subprefeitura Capela do Socorro",
    Subprefeitura %in% "Casa Verde/Cachoeirinha" ~ "Subprefeitura Casa Verde/Cachoeirinha",
    Subprefeitura %in% "Cidade Ademar" ~ "Subprefeitura Cidade Ademar",
    Subprefeitura %in% "Cidade Tiradentes" ~ "Subprefeitura Cidade Tiradentes",
    Subprefeitura %in% "Ermelino Matarazzo" ~ "Subprefeitura Ermelino Matarazzo",
    Subprefeitura %in% "Freguesia do Ó/Brasilândia" ~ "Subprefeitura Freguesia/Brasilândia",
    Subprefeitura %in% "Guaianases" ~ "Subprefeitura de Guaianases",
    Subprefeitura %in% "Ipiranga" ~ "Subprefeitura Ipiranga",
    Subprefeitura %in% "Itaim Paulista" ~ "Subprefeitura Itaim Paulista",
    Subprefeitura %in% "Itaquera" ~ "Subprefeitura Itaquera",
    Subprefeitura %in% "Jabaquara" ~ "Subprefeitura Jabaquara",
    Subprefeitura %in% "Jaçanã/Tremembé" ~ "Subprefeitura Jaçanã/Tremembé",
    Subprefeitura %in% "Lapa" ~ "Subprefeitura Lapa",
    Subprefeitura %in% "M'Boi Mirim" ~ "Subprefeitura M'Boi Mirim",
    Subprefeitura %in% "Mooca" ~ "Subprefeitura Mooca",
    Subprefeitura %in% "Parelheiros" ~ "Subprefeitura Parelheiros",
    Subprefeitura %in% "Penha" ~ "Subprefeitura Penha",
    Subprefeitura %in% "Perus" ~ "Subprefeitura Perus/Anhanguera",
    Subprefeitura %in% "Pinheiros" ~ "Subprefeitura Pinheiros",
    Subprefeitura %in% "Pirituba/Jaraguá" ~ "Subprefeitura Pirituba/Jaraguá",
    Subprefeitura %in% "Santana/Tucuruvi" ~ "Subprefeitura Santana/Tucuruvi",
    Subprefeitura %in% "Santo Amaro" ~ "Subprefeitura Santo Amaro",
    Subprefeitura %in% "São Mateus" ~ "Subprefeitura São Mateus",
    Subprefeitura %in% "São Miguel Paulista" ~ "Subprefeitura São Miguel Paulista",
    Subprefeitura %in% "Sapopemba" ~ "Subprefeitura Sapopemba",
    Subprefeitura %in% "Sé" ~ "Subprefeitura Sé",
    Subprefeitura %in% "Vila Maria/Vila Guilherme" ~ "Subprefeitura Vila Maria/Vila Guilherme",
    Subprefeitura %in% "Vila Mariana" ~ "Subprefeitura Vila Mariana",
    TRUE ~ "Subprefeitura de Vila Prudente"))

```

Então, descobrimos o valor total empenhado e agregamos as observações por Subprefeitura para realizar as análises

```{r Obras Prioritárias por Subprefeitura, echo=FALSE}

sum(op$valor_liquidado_2023)
obras_prioritarias <- op %>%
  group_by(Subprefeitura) %>% 
  summarise(total_op = sum(valor_liquidado_2023))

obras_prioritarias<- obras_prioritarias %>% 
   mutate("sp_nome" = case_when(
    Subprefeitura %in% "Aricanduva/Formosa/Carrão" ~ "Subprefeitura Aricanduva/Formosa/Carrão",
    Subprefeitura %in% "Butantã" ~ "Subprefeitura Butantã",
    Subprefeitura %in% "Campo Limpo" ~ "Subprefeitura Campo Limpo",
    Subprefeitura %in% "Capela do Socorro" ~ "Subprefeitura Capela do Socorro",
    Subprefeitura %in% "Casa Verde/Cachoeirinha" ~ "Subprefeitura Casa Verde/Cachoeirinha",
    Subprefeitura %in% "Cidade Ademar" ~ "Subprefeitura Cidade Ademar",
    Subprefeitura %in% "Cidade Tiradentes" ~ "Subprefeitura Cidade Tiradentes",
    Subprefeitura %in% "Ermelino Matarazzo" ~ "Subprefeitura Ermelino Matarazzo",
    Subprefeitura %in% "Freguesia do Ó/Brasilândia" ~ "Subprefeitura Freguesia/Brasilândia",
    Subprefeitura %in% "Guaianases" ~ "Subprefeitura de Guaianases",
    Subprefeitura %in% "Ipiranga" ~ "Subprefeitura Ipiranga",
    Subprefeitura %in% "Itaim Paulista" ~ "Subprefeitura Itaim Paulista",
    Subprefeitura %in% "Itaquera" ~ "Subprefeitura Itaquera",
    Subprefeitura %in% "Jabaquara" ~ "Subprefeitura Jabaquara",
    Subprefeitura %in% "Jaçanã/Tremembé" ~ "Subprefeitura Jaçanã/Tremembé",
    Subprefeitura %in% "Lapa" ~ "Subprefeitura Lapa",
    Subprefeitura %in% "M'Boi Mirim" ~ "Subprefeitura M'Boi Mirim",
    Subprefeitura %in% "Mooca" ~ "Subprefeitura Mooca",
    Subprefeitura %in% "Parelheiros" ~ "Subprefeitura Parelheiros",
    Subprefeitura %in% "Penha" ~ "Subprefeitura Penha",
    Subprefeitura %in% "Perus" ~ "Subprefeitura Perus/Anhanguera",
    Subprefeitura %in% "Pinheiros" ~ "Subprefeitura Pinheiros",
    Subprefeitura %in% "Pirituba/Jaraguá" ~ "Subprefeitura Pirituba/Jaraguá",
    Subprefeitura %in% "Santana/Tucuruvi" ~ "Subprefeitura Santana/Tucuruvi",
    Subprefeitura %in% "Santo Amaro" ~ "Subprefeitura Santo Amaro",
    Subprefeitura %in% "São Mateus" ~ "Subprefeitura São Mateus",
    Subprefeitura %in% "São Miguel Paulista" ~ "Subprefeitura São Miguel Paulista",
    Subprefeitura %in% "Sapopemba" ~ "Subprefeitura Sapopemba",
    Subprefeitura %in% "Sé" ~ "Subprefeitura Sé",
    Subprefeitura %in% "Vila Maria/Vila Guilherme" ~ "Subprefeitura Vila Maria/Vila Guilherme",
    Subprefeitura %in% "Vila Mariana" ~ "Subprefeitura Vila Mariana",
    TRUE ~ "Subprefeitura de Vila Prudente"))

```

Em seguida, conectamos com a base catográfica para georreferenciar os dados

```{r Obras Prioritárias regionalizado, echo=FALSE}
idrgp_op<- full_join(subprefeitura, obras_prioritarias, by = "sp_nome")

idrgp_op %>% 
  ggplot() +
  geom_sf(aes(fill = total_op, geometry = geometry)) +
  scale_fill_gradient(low="white",high="blue") +
  geom_sf_text(aes(label = sigla), color = "black", size = 1.5, fontface = "bold") + 
  theme_void()

```

Por fim, com objetivo meramente descritivo, vamos visualizar os dados das Obras Prioritárias em três gráicos, especificando a liquidação por Secretaria, a liquidação por Subprefeitura e liquidação por Ação Orçamentária.

```{r gráficos Obras Prioritárias, echo=FALSE}
op %>% 
  group_by(Secretaria) %>% 
  summarise(Liquidado_OP = sum(valor_liquidado_2023)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OP,
               y = Secretaria),
           show.legend = TRUE) +
  labs(title = "Obras Prioritárias por Órgãos") +
  theme_minimal()
  
#gráfico por Sub
op %>% 
  group_by(sp_nome) %>% 
  summarise(Liquidado_OP = sum(valor_liquidado_2023)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OP,
               y = sp_nome),
           show.legend = TRUE) +
  labs(title = "Obras Prioritárias por Subprefeitura") +
  theme_minimal()

op %>% 
  group_by(acao_orcamentaria) %>% 
  summarise(Liquidado_OP = sum(valor_liquidado_2023)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OP,
               y = acao_orcamentaria),
           show.legend = TRUE) +
  labs(title = "Orçamento cidadão por Ação Orçamentária") +
  theme_minimal()

```

### Orçamento Cidadão

Vamos incluir a base do Orçamento cidadão, encaminhada pela Secretaria da Fazenda (SF) e tratada por SEPEP para desvincular os projetos que também estão inseridos no escopo do Programa de Metas.

```{r Base Orçamento Cidadão, echo=FALSE}


df_oc1 <- readxl::read_excel("Planilha_OC_23_v2.xlsx")
df_oc <- df_oc1 %>% 
  filter(IDRGP == "Sim") %>%  
  select(`Nº Proposta`, DOTACAO, Secretaria, Subprefeitura, Liquidação)
df_oc<- df_oc %>% 
  rename("META"="Nº Proposta",
         sp_nome = Subprefeitura)
df_oc <- df_oc %>% 
  mutate(Liquidação = as.numeric(Liquidação))
df_oc <- df_oc %>% 
  mutate("sp_nome" = case_when(
    sp_nome %in% "Aricanduva/Formosa/Carrão" ~ "Subprefeitura Aricanduva/Formosa/Carrão",
    sp_nome %in% "Butantã" ~ "Subprefeitura Butantã",
    sp_nome %in% "Campo Limpo" ~ "Subprefeitura Campo Limpo",
    sp_nome %in% "Capela do Socorro" ~ "Subprefeitura Capela do Socorro",
    sp_nome %in% "Casa Verde" ~ "Subprefeitura Casa Verde/Cachoeirinha",
    sp_nome %in% "Cidade Ademar" ~ "Subprefeitura Cidade Ademar",
    sp_nome %in% "Cidade Tiradentes" ~ "Subprefeitura Cidade Tiradentes",
    sp_nome %in% "Ermelino Matarazzo" ~ "Subprefeitura Ermelino Matarazzo",
    sp_nome %in% "Freguesia/Brasilândia" ~ "Subprefeitura Freguesia/Brasilândia",
    sp_nome %in% "Guaianases" ~ "Subprefeitura de Guaianases",
    sp_nome %in% "Ipiranga" ~ "Subprefeitura Ipiranga",
    sp_nome %in% "Itaim Paulista" ~ "Subprefeitura Itaim Paulista",
    sp_nome %in% "Itaquera" ~ "Subprefeitura Itaquera",
    sp_nome %in% "Jabaquara" ~ "Subprefeitura Jabaquara",
    sp_nome %in% "Jaçanã/Tremembé" ~ "Subprefeitura Jaçanã/Tremembé",
    sp_nome %in% "Lapa" ~ "Subprefeitura Lapa",
    sp_nome %in% "M'Boi Mirim" ~ "Subprefeitura M'Boi Mirim",
    sp_nome %in% "Mooca" ~ "Subprefeitura Mooca",
    sp_nome %in% "Parelheiros" ~ "Subprefeitura Parelheiros",
    sp_nome %in% "Penha" ~ "Subprefeitura Penha",
    sp_nome %in% "Perus/Anhanguera" ~ "Subprefeitura Perus/Anhanguera",
    sp_nome %in% "Pinheiros" ~ "Subprefeitura Pinheiros",
    sp_nome %in% "Pirituba/Jaraguá" ~ "Subprefeitura Pirituba/Jaraguá",
    sp_nome %in% "Santana/Tucuruvi" ~ "Subprefeitura Santana/Tucuruvi",
    sp_nome %in% "Santo Amaro" ~ "Subprefeitura Santo Amaro",
    sp_nome %in% "São Mateus" ~ "Subprefeitura São Mateus",
    sp_nome %in% "São Miguel Paulista" ~ "Subprefeitura São Miguel Paulista",
    sp_nome %in% "Sapopemba" ~ "Subprefeitura Sapopemba",
    sp_nome %in% "Sé" ~ "Subprefeitura Sé",
    sp_nome %in% "Vila Maria/Vila Guilherme" ~ "Subprefeitura Vila Maria/Vila Guilherme",
    sp_nome %in% "Vila Mariana" ~ "Subprefeitura Vila Mariana",
    TRUE ~ "Subprefeitura de Vila Prudente")) 

df_oc <- df_oc %>% 
  mutate(acao_orc = stringr::str_sub(DOTACAO, start = 19, end = 23))


df_sub_oc <- df_oc %>% 
  group_by(sp_nome) %>% 
  summarise(total_oc = sum(Liquidação))
sum(df_sub_oc$total_oc)
print(df_sub_oc)


```


Os valores do Orçamento Cidadão estão concentrados em apenas 6 subprefeituras, totalizando R$ 35.400.344. 


Agora vamos construir uma base do Orçamento Cidadão com os dados de georreferenciamento para, posteriormente, juntar com as bases do PdM e das Obras Prioritárias.

```{r Base orçamento Cidadão Georreferênciada, echo=FALSE}

idrgp_oc<- full_join(subprefeitura, df_sub_oc, by = "sp_nome")
idrgp_oc<- idrgp_oc %>% 
  mutate(total_oc = ifelse( is.na(total_oc), 0, total_oc))

idrgp_oc %>% 
  ggplot() +
  geom_sf(aes(fill = total_oc, geometry = geometry)) +
  scale_fill_gradient(low="white",high="blue") +
  geom_sf_text(aes(label = sigla), color = "black", size = 1.5, fontface = "bold") + 
  theme_void()
```

Por fim, com objetivo meramente descritivo, vamos visualizar os dados do Orçamento Cidadão em três gráicos, especificando a liquidação por Secretaria, a liquidação por Subprefeitura e a liquidação por Ação Orçamentária.


```{r Gráficos do orçamento Cidadão, echo=FALSE}

#gráfico por órgão:
df_oc %>% 
  group_by(Secretaria) %>% 
  summarise(Liquidado_OC = sum(Liquidação)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OC,
               y = Secretaria),
           show.legend = TRUE) +
  labs(title = "Orçamento cidadão por Órgãos") +
  theme_minimal()
  
#gráfico por Sub
df_oc %>% 
  group_by(sp_nome) %>% 
  summarise(Liquidado_OC = sum(Liquidação)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OC,
               y = sp_nome),
           show.legend = TRUE) +
  labs(title = "Orçamento cidadão por Subprefeitura") +
  theme_minimal()

#gráfico por ação orçamentária
df_oc %>% 
  group_by(acao_orc) %>% 
  summarise(Liquidado_OC = sum(Liquidação)) %>% 
  ggplot() +
  geom_col(aes(x = Liquidado_OC,
               y = acao_orc),
           show.legend = TRUE) +
  labs(title = "Orçamento cidadão por Ação Orçamentária") +
  theme_minimal()

##
```


### Criando uma base única para o cálculo do IDRGP

Agora vamos juntar as bases do Orçamento Cidadão, Obras Prioritárias e Programa de Metas para clacular o IdRGP.

Além disso, também vamos calculara soma total do valor liquidado por subprefeitura; o percentual que esse valor representa entre elas e a diferença entre esse percentual e o percentual de referencia do IDRGP.

```{r Valores totais, echo=FALSE}

#Junatndo bancos
idrgp<- full_join(obras_prioritarias, df_sub_oc, by = "sp_nome")
idrgp<- full_join(idrgp, gp_idrgp_pdm, by = "sp_nome")
idrgp<- full_join(subprefeitura, idrgp, by = c("sp_nome", "ref_idrgp"))

idrgp<- idrgp %>% 
  mutate(total_oc = ifelse( is.na(total_oc), 0, total_oc),
         total_op = ifelse( is.na(total_op), 0, total_op))
idrgp<- idrgp %>% 
  mutate(total_idrgp_23 = total_oc + total_op + valor_liquidado,
         p_liq_23 = total_idrgp_23/sum(total_idrgp_23), 
         diferenca23 = p_liq_23 - ref_idrgp)
idrgp %>% select(NOME, total_idrgp_23, p_liq_23, diferenca23)

```

### Intervalo de confiança

Agora, vamos calclualr o intervalo de confiança para o índice de referÊncia. Para isso, primeiramente, vamos avaliar se os dados correspondem a uma distribuição normal.

Primeiramente, realizaremos um teste Shapiro de Normalidade e, na sequência, um Teste Kolmogorov-Smirnov.

```{r Testes de normalidade, echo=FALSE}

# Teste Shapiro. testa na normalidade dos dados do índice de referância.
shapiro.test(idrgp$ref_idrgp)
#O p-valor for < 0.05 indica que os dados não apresentam normalidade.
# No caso, o resultado encontrado aponta que os dados poderiam ser enquadrados numa distribuição normal.

# Teste Kolmogorov-Smirnov. Também tesa a normalidade dos dados.
ks.test(idrgp$ref_idrgp,"pnorm",mean(idrgp$ref_idrgp),sd(idrgp$ref_idrgp))
# O tsste também resultou em (não rejeição) curva normal para os dados. 

#Os mesmos testes para o percentual liquidado de 2023
shapiro.test(idrgp$p_liq_23)
ks.test(idrgp$p_liq_23,"pnorm",mean(idrgp$p_liq_23),sd(idrgp$p_liq_23))

```

Ambos os testes não rejeitaram a aproximação dos dados de referência do IDRGP como uma curva normal.

Com isso, torna-se possível construir um intervalo de confiança tanto a partir do desvio padrão, quanto a partir de um t.test pareando a distribuição do índice de referência e o percentual total.

Calcularemos os dois:

-   Para o cálculo do intervalo de confiança tradicional, adotaremos o rigor de 3 sigmas, sobre o valor de referência do IRDGP.

-   Para o t.test pareado, manteremos o padrão de 95% de confiança, pois as curvas já estão se ajustando entre si pela diferença.

```{r Intervalo de Confiança, echo= FALSE}

#Intervalo de confiança com 3 sigmas
idrgp<- idrgp %>% 
  mutate(int_inf= ref_idrgp - 3*(sd(ref_idrgp)/sqrt(32)),
         int_sup= ref_idrgp + 3*(sd(ref_idrgp)/sqrt(32)))
idrgp<- idrgp %>% 
  mutate("Status1" = case_when(
    idrgp$p_liq_23 <  int_inf ~ "Aquem da referência do IDRGP",
    idrgp$p_liq_23 >  int_sup ~ "Acima da referência do IDRGP",
    TRUE ~ "Dentro da referência"))


teste_t<-t.test(idrgp$ref_idrgp, idrgp$p_liq_23, paired = T)
idrgp<- idrgp %>% 
  mutate("Status2" = case_when(
    idrgp$diferenca23 <  teste_t$conf.int[1] ~ "Aquem da referência do IDRGP",
    idrgp$diferenca23 >  teste_t$conf.int[2] ~ "Acima da referência do IDRGP",
    TRUE ~ "Dentro da referência"))

idrgp %>% select(NOME, Status1, Status2)
case_when(idrgp$Status1 != idrgp$Status2 ~ idrgp$NOME)


```

O resulado do primeiro intervalo de confiança resultou em quatro distinções quando calculado a partir do índice de referência (com 3 sigmas) e quando calculado pelo t.test (95%). As  Subprefeituras de Guaianases, Pirituba-Jaraguá, Vila Maria-Vila Guilherme e Santana-Tucuruvi passaram de aquém do ´indice para dentro do índice.

Podemos visualizar a distribuição da distância entre o valor de referênncia e os resultados de 2023 nos gráficos abaixo, referentes a cada intervalo de confiança adotado.

```{r gráficos de diferença, echo=FALSE }
# gráfico percentual liquidado x referência
idrgp %>% 
  ggplot() +
  geom_col(aes(x = p_liq_23,
               y = forcats::fct_reorder(sp_nome, ref_idrgp),
               fill = Status2),
           show.legend = TRUE) +
  scale_fill_manual(values = c("yellow", "red", "blue")) +
  scale_x_continuous(name = NULL,
                     labels = scales::comma_format(big.mark = ".",
                                                   decimal.mark = ",")) +
  geom_point(mapping = aes(x = ref_idrgp,
                           y = sp_nome,
                           colour = "Referência pelo IDRGP"),
             show.legend = TRUE) +
  labs(title = "IDRGP 2023",
       y = "") +
  theme_minimal()+
  theme(legend.title = element_blank(),
        legend.position = "bottom")

# gráfico percentual liquidado x referência 2
idrgp %>% 
  ggplot() +
  geom_col(aes(x = p_liq_23,
               y = forcats::fct_reorder(sp_nome, ref_idrgp),
               fill = Status1),
           show.legend = TRUE) +
  scale_fill_manual(values = c("yellow", "red", "blue")) +
  scale_x_continuous(name = NULL,
                     labels = scales::comma_format(big.mark = ".",
                                                   decimal.mark = ",")) +
  geom_point(mapping = aes(x = ref_idrgp,
                           y = sp_nome,
                           colour = "Referência pelo IDRGP"),
             show.legend = TRUE) +
  labs(title = "IDRGP 2023",
       y = "") +
  theme_minimal()+
  theme(legend.title = element_blank(),
        legend.position = "bottom")

# Gráfico da distância 1
idrgp %>% 
  ggplot() +
  geom_col(aes(x = diferenca23,
               y = NOME,
               fill = Status1),
           show.legend = T) +
  scale_fill_manual(values = c("yellow", "red", "blue")) +
  labs(title = "Distâcias do IDRGP 2023 ao referencial",
       y = "") +
  theme_minimal()

# Gráfico da distância 2
idrgp %>% 
  ggplot() +
  geom_col(aes(x = diferenca23,
               y = NOME,
               fill = Status2),
           show.legend = T) +
  scale_fill_manual(values = c("yellow", "red", "blue")) +
  labs(title = "Distâcias do IDRGP 2023 ao referencial",
       y = "") +
  theme_minimal()

```

### Visualizações Gráficas

Para melhor compreender a distribuição do IDRGP no território da cidade, apresentamos abaixo três mapas.

-   O primiro oferece a visualização do valor total liquidado em cada uma das Subprefeituras, segundo o que foi apurado para o IDRGP.
-   O segundo, corresponde ao índice em si, isto é o cálculo da diferença entre o valor de referencia e o percentual do orçamento liquidado por Subprefeitura.
-   Finalente, o terceiro, permite visualizar a composição do índice, de acordo com o intervalo de confiança de 95% a partir do teste t pareado.

```{r Mapas, echo=FALSE}

# Mapa 1 - valor liquidado 2023
idrgp %>% 
  ggplot()+
  geom_sf(aes(fill = total_idrgp_23, geometry = geometry)) +
  scale_fill_gradient(low="white",high="blue") +
  geom_sf_text(aes(label = sigla), color = "black", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "Valor liquidado utilizado no cálculo do IDRGP 2023*",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)

# Mapa 2 - diferença 2023
idrgp %>% 
  ggplot()+
  geom_sf(aes(fill = diferenca23, geometry = geometry)) +
  scale_fill_gradient(low="red",high="yellow") +
  geom_sf_text(aes(label = sigla), color = "white", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "Índice da Distribuição Regional do Gasto Público, 2023*",
       subtitle = "*Diferença entre valor de refencia do índice e o percentual liquidado do orçamento ",
       fill = "Diferença",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)

# mapa 3 - análise IDRGP
idrgp %>% 
  ggplot()+
  geom_sf(aes(fill = Status2)) +
  scale_fill_manual(values = c("yellow","red", "blue")) +
  geom_sf_text(aes(label = sigla), color = "white", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "IDRGP 2023",
       subtitle = "t.test pareado com intervalo de confiança de 95%",
       fill = "Aproximação da referência do IDRGP",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)

# mapa 3.1 - análise IDRGP
idrgp %>% 
  ggplot()+
  geom_sf(aes(fill = Status1)) +
  scale_fill_manual(values = c("yellow","red", "blue")) +
  geom_sf_text(aes(label = sigla), color = "white", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "Variação significativa do gasto de 2023 da referência do IDRGP",
       subtitle = "Intervalo de confiança de 3 sigmas sobre o valor de referência",
       fill = "Aproximação do IDRGP",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)

```

### Comparando com os dados de 2022

Por fim, vamos traçar um paralelo com os dados do IDRGP 2022

```{r mapa idrgp22, echo=FALSE}
###Inserndo dados de 2022
idrgp22<- read_excel("consolidado_idrgp_2022.xlsx")
idrgp22<- idrgp22 %>% 
  mutate(tot22= sum(idrgp_2022),
         ref22= sum(valor_por_ano),
         p_liq_22 = ( liq_pdm +liq_obras + liq_oc )/tot22, 
         ref_idrgp22 = valor_por_ano/ref22,
         diferenca22= p_liq_22 - ref_idrgp22)
t.test(idrgp22$p_liq_22, idrgp22$ref_idrgp22)
idrgp22<- idrgp22 %>% 
  mutate("Status" = case_when(
    idrgp22$diferenca22 <  - 0.01244564 ~ "Aquem da referência do IDRGP",
    idrgp22$diferenca22 >  0.01244564 ~ "Acima da referência do IDRGP",
    TRUE ~ "Dentro da referência"))
idrgp22<- idrgp22 %>% 
  rename(NOME = sp_nome)
idrgp22<- idrgp22 %>% 
  mutate(NOME = ifelse(NOME == "M'BOI MIRIM", "M BOI MIRIM", NOME))
map_22<- inner_join(idrgp22, subprefeitura, by = "NOME")
map_22 %>% 
  ggplot()+
  geom_sf(aes(fill = Status, geometry = geometry )) +
  scale_fill_manual(values = c("yellow","red", "blue")) +
  geom_sf_text(aes(label = sigla, geometry = geometry), color = "white", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "IDRGP 2022",
       subtitle = "t.test com intervalo de confiança de 95%",
       fill = "Aproximação da referência do IDRGP",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)
```


### IDRGP do biênio 2022-2023

Também é possível agregar os dados dos anso de 2022 e 2023 e ter um retrato do biênio


```{r IDRGP 22+23, echo=FALSE}

### Soma dos gastos de 2022 e 2023
mapa_22e23<- inner_join( map_22, idrgp, by = c("NOME", "sigla", "geometry", "sp_nome", "ref_idrgp"))
mapa_22e23<- mapa_22e23 %>% 
  mutate(liq_22e23 = idrgp_2022 + total_idrgp_23,
         p_liq_22e23 = liq_22e23/ sum(liq_22e23)) %>% 
  select(sigla, NOME, sp_nome, geometry, ref_idrgp, idrgp_2022, total_idrgp_23, liq_22e23, p_liq_22e23)
mapa_22e23<- mapa_22e23 %>% 
  mutate(diferenca = p_liq_22e23 - ref_idrgp)

teste_t_agreg<-t.test(mapa_22e23$ref_idrgp, mapa_22e23$p_liq_22e23, paired = T)
mapa_22e23<- mapa_22e23 %>% 
  mutate("Status" = case_when(
    mapa_22e23$diferenca <  teste_t_agreg$conf.int[1] ~ "Aquem da referência do IDRGP",
    mapa_22e23$diferenca >  teste_t_agreg$conf.int[2] ~ "Acima da referência do IDRGP",
    TRUE ~ "Dentro da referência"))


mapa_22e23 %>% 
  ggplot()+
  geom_sf(aes(fill = Status, geometry = geometry )) +
  scale_fill_manual(values = c("yellow","red", "blue")) +
  geom_sf_text(aes(label = sigla, geometry = geometry), color = "white", size = 2, fontface = "bold") +
  theme_void() +
  labs(title = "IDRGP no biênio 2022 e 2023",
       subtitle = "t.test com intervalo de confiança de 95%",
       fill = "Aproximação da referência do IDRGP",
       caption = "Fonte: PMSP/SOF; SMADS; SME; SMS. Elaboração: SGM/SEPEP/CP.",
       x = NULL, y = NULL)

```

#### Análises

```{r echo=FALSE}

##### Comparação 2022 e 2023

(a <- idrgp22 %>% 
   select(NOME, idrgp_2022, ref_idrgp22) %>%
   rename(
  subprefeitura = NOME,
  idrgp22 = idrgp_2022))

(b <- idrgp %>% 
    select(NOME, total_idrgp_23, Status1) %>%
    rename(subprefeitura = NOME,
           idrgp23 = total_idrgp_23))

(comparacao <- left_join(a, b, by = intersect(names(a), names(b))) %>% 
    arrange(desc(ref_idrgp22)) %>% 
    mutate(valor_esperado = ref_idrgp22*1250000000))

comparacao_long <- gather(comparacao, key = "idrgp", value = "valor", idrgp22, idrgp23)

comparacao_long <- comparacao_long %>%
  mutate(subprefeitura = factor(subprefeitura, levels = unique(subprefeitura[order(idrgp, decreasing = TRUE)])))

# Análise Gráfica

ggplot(comparacao_long, aes(x = subprefeitura, y = valor, fill = idrgp)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_line(data = comparacao_long, aes(x = subprefeitura, y = valor_esperado, group = Status1), color = "orange", linetype = "dashed", linewidth = 0.25) +
  facet_wrap(vars(Status1), nrow = 3)+
  labs(x = NULL, y = NULL, fill = NULL) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "bottom")

rm(list = c("a", "b"))
  

```

#### Fichas das subprefeituras

```{r echo=FALSE}

##### Glossário de ações orçamentárias ####

colnames(base_da)

txt_acao_orc <- base_da %>% 
  filter(tipo_regionalizacao == "Despesa Regionalizável") %>% 
  select(codigo_proj_ativ, descricao_proj_ativ) %>% 
  mutate(codigo_proj_ativ = str_replace(codigo_proj_ativ, "^(.{1})(.*)$", "\\1.\\2")) %>%
  rename(acao_orcamentaria = codigo_proj_ativ) %>% 
  unique()



##### Fichas das subprefeituras ####

a <- base_da_pdm %>% 
  group_by(subprefeitura, acao_orcamentaria) %>% 
  summarise(liq_pdm = sum(valor_liquidado),
            acao_orcamentaria = first(acao_orcamentaria)) %>% 
  filter(liq_pdm > 0)

sum(a$liq_pdm) == sum(base_da_pdm$valor_liquidado)


colnames(df_oc)

b <- df_oc %>% 
  select(-META, -Secretaria, - DOTACAO) %>% 
  rename(subprefeitura = sp_nome,
         liq_oc = `Liquidação`,
         acao_orcamentaria = acao_orc) %>% 
  group_by(subprefeitura, acao_orcamentaria) %>% 
  summarise(liq_oc = sum(liq_oc),
            acao_orcamentaria = first(acao_orcamentaria)) %>% 
  filter(liq_oc > 0)

c <- op %>% 
  select(sp_nome, valor_liquidado_2023, acao_orcamentaria) %>% 
  rename(subprefeitura = sp_nome,
         liq_op = valor_liquidado_2023) %>% 
  group_by(subprefeitura, acao_orcamentaria) %>% 
  summarise(liq_op = sum(liq_op),
            acao_orcamentaria = first(acao_orcamentaria)) %>% 
  filter(liq_op > 0)

fichas_subp <- a %>% 
  full_join(b, by = intersect(names(a), names(b))) %>% 
  replace_na(list(liq_pdm = 0, liq_oc = 0)) %>% 
  arrange(subprefeitura, acao_orcamentaria)

fichas_subp <- fichas_subp %>%
  full_join(c, by = intersect(names(fichas_subp), names(c))) %>% 
  replace_na(list(liq_pdm = 0, liq_oc = 0, liq_op = 0))

fichas_subp <- fichas_subp %>% 
  left_join(txt_acao_orc, by = "acao_orcamentaria")

fichas_subp <- fichas_subp %>% 
  select(subprefeitura, acao_orcamentaria, descricao_proj_ativ, liq_pdm, liq_oc, liq_op) %>% 
  mutate(liq_23 = liq_pdm + liq_oc + liq_op)



```

